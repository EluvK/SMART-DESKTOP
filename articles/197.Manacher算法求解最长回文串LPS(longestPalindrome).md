---
title: "Manacher算法求解最长回文串LPS(longestPalindrome)"
tags: 
categories: 
- "算法"
---

>马拉车算法 Manacher‘s Algorithm 是用来查找一个字符串的最长回文子串的线性方法，由一个叫Manacher的人在1975年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。
#### Manacher优势：
- 只需要遍历一次
- 动态规划时间和空间复杂度都是O(n<sup>2</sup>)，而Manacher算法均为O(n);
比较（下面为动态规划解法、上面为Manacher解法）
![image](https://github.com/EluvK/Image_server/raw/master/2020-01/004.png)

LeetCode 第5题 最长回文串，在题解里看到的算法（其余解法：[LeetCode5.最长回文子串](https://blog.eluvk.cn/?p=193)），找了好几篇介绍，加上手动模拟才算弄懂这个算法的含义，记录分享一下我的理解：
#### 步骤：
首先预处理，然后计算里分四个步骤：计算`p[i]` (核心操作)，继续中心拓展，维护最远右边界，维护要返回的答案。一步步说明：
0. 预处理：在开头结尾以及每个字符串中间加上一个`#`号，可以让字符串长度一定是奇数（中心一定是一个字符而不是两个字符中间）且不影响最长回文串的结果。再在最开始加一个`$`。
1. 对于新的字符串的定义几个概念：
	1. `p[i]`:`p[i]`表示第`i`个字符作为中心的最长回文串半径，比如`$#a#`半径就是`a#`也就是2
	2. `mx`:`mx`表示最远右边界的位置，当前的最远右边界就是前面所有的`i`，`i+p[i]`所能达到的最大值
	3. `c`:`c`表示当前最远右边界的中心，c为前面的所有i中的一个，它的半径向右过去就是最远右边界
2. 计算里的四个步骤：分别对应代码12、13-14、15-18、19-22行
	1. 计算`p[i]`:`p[i] = mx > i ? min(p[2 * c - i], mx - i) : 1;`
	计算`p[i]`时，如果`mx > i`,说明`i`在前面计算过的最远右边界之内，相对于中心点的对称点是`2 * c - i`,简称为`j`,`j = 2 * c - i`有`(j < c < i)`;`i`和`j`关于中心点`c`对称，且都在关于c对称的回文串内，同时前面计算过的`p[j]`的意思是关于`j`对称的回文串，关于j对称且都在`c`的范围`[c-mx,c+mx]`内的部分（就是两者取较小值），自然也适用于`p[i]`上，这一部分就无须检验，`p[i]`至少有这么大。如果不满足这些条件，`p[i]`至少是1，自己是回文串。
	2. 继续中心拓展
	3. 如果当前计算出来的`p[i]`更远，就更新`mx`和`c`。
	4. 如果当前计算出来的结果更大，就更新最大结果
3. 关于返回字符串的起始位置和长度和预处理过的字符串的位置关系
原回文串长度=现回文串半径-1
原回文串起点=(现中心-现半径)/2



#### 代码：
```cpp
class LPS_Manacher {
public:
    string longestPalindrome(string s) {
        string t = "$#";
        for(auto c : s) {
            t += c;
            t += "#";
        }
        vector<int> p(t.size(), 0);
        int mx = 0, c = 0, resL = 0, resC = 0;
        for(int i = 1; i < t.size(); i++) {
            p[i] = mx > i ? min(p[2 * c - i], mx - i) : 1;
            while(t[i + p[i]] == t[i - p[i]])
                p[i]++;
            if(mx < i + p[i]) {
                c = i;
                mx = i + p[i];
            }
            if(resL < p[i]) {
                resL = p[i];
                resC = i;
            }
        }
        return s.substr((resC - resL) / 2, resL - 1);
    }
};
```